ğŸ”¹ Map in Java â€“ Hierarchy (Interface vs Class)
1ï¸âƒ£ What is Map? (Interview one-liner)
Map is an object that stores data in keyâ€“value pairs, where keys are unique and values can be duplicated.

ğŸ“Œ Package: java.util
ğŸ“Œ Map is NOT a child of Collection

2ï¸âƒ£ Map Hierarchy (Interface vs Class)

Map                           (interface)
â”‚
â”œâ”€â”€ HashMap                   (class)
â”‚     â””â”€â”€ LinkedHashMap       (class)
â”‚
â”œâ”€â”€ SortedMap                 (interface)
â”‚     â””â”€â”€ NavigableMap        (interface)
â”‚           â””â”€â”€ TreeMap       (class)
â”‚
â”œâ”€â”€ Hashtable                 (class - legacy)
â”‚
â”œâ”€â”€ ConcurrentMap             (interface)
â”‚     â””â”€â”€ ConcurrentHashMap   (class)
â”‚
â””â”€â”€ EnumMap                   (class)

4ï¸âƒ£ Important Map Interfaces (Know This Clearly)

ğŸ”¹ Map (Interface)
Stores keyâ€“value pairs
Keys must be unique
Allows one null key (depends on implementation)
Values can have multiple nulls

ğŸ”¹ SortedMap (Interface)
Keys are stored in sorted order
Sorting based on:
Natural ordering (Comparable)
Custom ordering (Comparator)

ğŸ”¹ NavigableMap (Interface)
Adds navigation methods:
lowerKey(), higherKey()
floorKey(), ceilingKey()
firstEntry(), lastEntry()

ğŸ”¹ ConcurrentMap (Interface)
Designed for concurrent access
Atomic operations:
putIfAbsent()
remove(key, value)
replace()

5ï¸âƒ£ Important Map Classes (High-Level)

ğŸ”¹ HashMap
No ordering guarantee
Allows one null key, multiple null values
Not thread-safe
Uses hashing

ğŸ”¹ LinkedHashMap
Maintains insertion order
Can maintain access order (LRU cache)
Slightly slower than HashMap

ğŸ”¹ TreeMap
Always sorted by key
Uses Red-Black Tree
âŒ No null key
Slower than HashMap (O(log n))

ğŸ”¹ Hashtable (Legacy)
Synchronized (thread-safe)
âŒ No null key or value
Slower â†’ replaced by ConcurrentHashMap

ğŸ”¹ ConcurrentHashMap (ğŸ”¥ Very Important)
Thread-safe & high performance
No locking on entire map
âŒ No null key or value
Uses bucket-level locking (Java 8+)

ğŸ”¹ EnumMap
Keys must be enum type
Very fast
Internally uses array
âŒ No null keys

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ğŸ‘‰ bucket â†’ hashing â†’ collision â†’ treeify

ğŸ”¹ HashMap Internal Working (Java 8+)
1ï¸âƒ£ Basic Structure of HashMap
ğŸ”¹ Internal Data Structure

HashMap internally uses an array of Node
Node<K,V>[] table;

Each Node contains:
class Node<K,V> {
    int hash;
    K key;
    V value;
    Node<K,V> next; // for collision (linked list / tree)
}

ğŸ“Œ This array index is called a bucket.

2ï¸âƒ£ What is a Bucket?

A bucket is an index position in the internal array where key-value pairs are stored.

Example:
Default capacity = 16
Index range = 0 to 15

Each bucket can have:
Single entry
Linked list (collision)
Red-Black Tree (after treeify)

3ï¸âƒ£ Hashing (Very Important)
ğŸ”¹ Step 1: hashCode()
Keyâ€™s hashCode() is called
int h = key.hashCode();

ğŸ”¹ Step 2: Hash Spreading
hash = h ^ (h >>> 16);
ğŸ‘‰ Improves distribution of keys across buckets

ğŸ”¹ Step 3: Index Calculation
index = (n - 1) & hash;
n = table size (power of 2)

4ï¸âƒ£ put() Operation â€“ Step by Step
Example:
map.put("A", 10);

Internal Flow:
Compute hash of key "A"
Calculate bucket index
Check bucket:
Empty â†’ insert Node
Not empty â†’ collision handling

5ï¸âƒ£ Collision Handling

Collision occurs when multiple keys map to the same bucket index.

Java 7:
Only Linked List
Java 8+:
Starts as Linked List
Converts to Red-Black Tree if conditions met

6ï¸âƒ£ Treeify (ğŸ”¥ Interview Favorite)
ğŸ”¹ When does LinkedList convert to Tree?
Condition	Value
Threshold	8 nodes
Min capacity	64
Structure	Red-Black Tree

ğŸ‘‰ If capacity < 64 â†’ resize instead of treeify

8ï¸âƒ£ get() Operation â€“ Step by Step
map.get(key);

Calculate hash
Find bucket index
Compare hash
Compare key using equals()
Return value

9ï¸âƒ£ Resize (Rehashing)
ğŸ”¹ When Resize Happens
Load factor = 0.75

Resize condition:
size > capacity * loadFactor

ğŸ”¹ Resize Action
Capacity doubles
Recalculate bucket positions
Reinsert nodes

Null Handling - ğŸ‘‰ Null key always goes to bucket index 0
