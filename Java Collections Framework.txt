Java Collections Framework

Why Collections?

Problem with Arrays - Fixed Size and no in built methods like (add/remove/search utilities).
Backend app need dynamic, fast, scalable data handling. Collection solves this


Collection Framework architecture

	Iterable
	   |
	Collection
	   |
	-------------------------------------
	|                 |                 |
	List              Set               Queue


Separate Hierarchy 

	Map
 	|
	----------------------------
	|             |            |
	HashMap   LinkedHashMap  TreeMap


Implementations of List interfaces

	List (Interface)
 	|
 	---------------------------------------------------
	|                  |                |             |
	ArrayList       LinkedList        Vector        Stack

	List interface has an ordered, index based, and duplicates allowed collection.

Array List

â¦	Dynamic Array,
â¦	random access is fast,
â¦	Not thread safe	

Internal implementations of Array list

â¦	Backed by Object[] array with initial capacity of 10 and when exceeded it will grow by 50%.
â¦	If size is know before we can give custom Capacity like 100, 1000 it will improve performance because resizing is costly.
â¦	Array list achieves fast random access by its internal architecture object array[].
â¦	ListÂ implements RandomAccess Marker interface.

Linked List

Linked list implements List and Deque interfaces, so it can behave like 

List - ordered Collection
Queue and stack

LinkedList supports index-based operations, but internally it is node-based. Methods like get(index) and add(index) require traversal, so they are O(n). Java optimizes traversal by starting from head or tail depending on index position.

LinkedList stores elements as nodes, where each node contains:

â¦	Data
â¦	Reference to previous node
â¦	Reference to next node

â¡ It is a Doubly Linked List    

Vector

Vector is a thread-safe growable array same as ArrayList but is considered legacy due to performance issues and 
poor concurrency design.  

Stack

Stack is a legacy synchronized LIFO class extending Vector. In modern Java, Deque implementations like 
ArrayDeque or LinkedList should be used instead.

------------------------------------------------------------------------------------------------------------------------------------------------------------

Set Interface 

ğŸ”¹ Key Characteristics

âœ” No duplicates allowed
âœ” At most one null (depends on implementation)
âœ” No index-based access
âœ” Order depends on implementation

Collection
   â”‚
   â””â”€â”€ Set
        â”œâ”€â”€ HashSet
        â”‚     â””â”€â”€ LinkedHashSet
        â””â”€â”€ SortedSet
              â””â”€â”€ NavigableSet
                     â””â”€â”€ TreeSet

 Methods in Set Interface

ğŸ‘‰ Set does NOT add new methods
ğŸ‘‰ It only inherits from Collection

HashSet

âœ” No order guarantee
âœ” Allows one null
âœ” Not synchronized
âœ” Fastest (O(1) average)

ğŸ”¹ Internal Working (VERY IMPORTANT ğŸ”¥)
HashSet is backed by HashMap

ğŸ”¹ Hashing Flow
â¦	hashCode() called
â¦	Bucket location found
â¦	equals() used to avoid duplicates

LinkedHashSet

ğŸ”¹ Characteristics

âœ” Maintains insertion order
âœ” Slightly slower than HashSet
âœ” One null allowed

ğŸ”¹ Internal
HashMap + Doubly Linked List

TreeSet (Sorted Set)

ğŸ”¹ Characteristics

âœ” Sorted order
âœ” No null allowed
âœ” Slower than HashSet

ğŸ”¹ Internal Working
Backed by Red-Black Tree

SortedSet & NavigableSet Methods
ğŸ”¹ SortedSet

â¦	first()
â¦	last()
â¦	headSet(E toElement)
â¦	tailSet(E fromElement)
â¦	subSet(E from, E to)

ğŸ”¹ NavigableSet (Advanced)

â¦	lower(E e)
â¦	floor(E e)
â¦	ceiling(E e)
â¦	higher(E e)
â¦	pollFirst()
â¦	pollLast()
â¦	descendingSet()

------------------------------------------------------------------------------------------------------------------------------------------------------------

Queue Interface

Stores elements in FIFO order
methods of Queue - offer / poll / peek

Iterable (interface)
  â†‘
Collection (interface)
  â†‘
Queue (interface)
   â”œâ”€â”€ Deque (interface)
   â”‚     â”œâ”€â”€ ArrayDeque (class)
   â”‚     â””â”€â”€ LinkedList (class)
   â”‚
   â”œâ”€â”€ PriorityQueue (class)
   â”‚
   â””â”€â”€ BlockingQueue (interface)
         â”œâ”€â”€ ArrayBlockingQueue      (class)
         â”œâ”€â”€ LinkedBlockingQueue     (class)
         â”œâ”€â”€ PriorityBlockingQueue   (class)
         â”œâ”€â”€ DelayQueue              (class)
         â””â”€â”€ SynchronousQueue        (class)

Queue Implementations (Non-Concurrent)

 LinkedList (Queue + Deque)

Internal Architecture
âœ” Doubly Linked List
âœ” Node has prev, next, item

ArrayDeque

Internal Architecture
âœ” Resizable circular array
âœ” Head & tail pointers
âœ” Faster than LinkedList
âœ” No null allowed

PriorityQueue

Internal Architecture ğŸ”¥
âœ” Binary Heap (Min Heap)
âœ” Array-backed
âœ” Ordering by priority
âœ” Not FIFO
âœ” No null

Use Case

âœ” Task scheduling
âœ” Job queues
âœ” Dijkstra algorithm

Concurrent Queue's - Blocking Queue
